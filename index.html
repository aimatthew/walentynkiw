<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíï Dla Wikusi üíï</title>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@500;600;700&family=Quicksand:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Quicksand', sans-serif;
            overflow: hidden;
            position: relative;
        }

        .bg-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        .bg-base {
            background: 
                radial-gradient(ellipse at 10% 20%, rgba(120, 50, 80, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse at 90% 80%, rgba(180, 80, 100, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(60, 20, 40, 0.2) 0%, transparent 70%),
                linear-gradient(180deg, #1a0a10 0%, #2d1520 30%, #3d1f2d 60%, #2a1018 100%);
            z-index: 1;
        }

        .bg-aurora {
            z-index: 2; opacity: 0.4;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 100, 150, 0.1) 50%, transparent 100%);
            animation: auroraMove 15s ease-in-out infinite;
        }

        @keyframes auroraMove {
            0%, 100% { transform: translateX(-30%) rotate(-5deg) scale(1.5); opacity: 0.3; }
            50% { transform: translateX(30%) rotate(5deg) scale(1.5); opacity: 0.5; }
        }

        .bg-bokeh { z-index: 3; }
        .bokeh-circle { position: absolute; border-radius: 50%; filter: blur(40px); animation: bokehFloat 20s infinite ease-in-out; }
        .bokeh-circle:nth-child(1) { width: 300px; height: 300px; background: rgba(255, 100, 130, 0.15); top: 10%; left: 5%; }
        .bokeh-circle:nth-child(2) { width: 250px; height: 250px; background: rgba(255, 150, 180, 0.12); top: 60%; right: 10%; animation-delay: -5s; }
        .bokeh-circle:nth-child(3) { width: 200px; height: 200px; background: rgba(255, 80, 120, 0.1); bottom: 20%; left: 20%; animation-delay: -10s; }
        .bokeh-circle:nth-child(4) { width: 350px; height: 350px; background: rgba(255, 120, 160, 0.08); top: 30%; right: 25%; animation-delay: -15s; }

        @keyframes bokehFloat {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(50px, -30px) scale(1.1); }
            50% { transform: translate(-30px, 50px) scale(0.95); }
            75% { transform: translate(40px, 20px) scale(1.05); }
        }

        .bg-particles { z-index: 4; }
        .particle { position: absolute; background: white; border-radius: 50%; animation: particleTwinkle 4s infinite ease-in-out; }

        @keyframes particleTwinkle {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.5); }
        }

        .bg-falling { z-index: 5; pointer-events: none; }
        .falling-item { position: absolute; top: -60px; animation: gentleFall linear infinite; opacity: 0.6; filter: drop-shadow(0 0 10px rgba(255, 150, 180, 0.5)); }

        @keyframes gentleFall {
            0% { transform: translateY(0) rotate(0deg) translateX(0); opacity: 0; }
            5% { opacity: 0.6; }
            95% { opacity: 0.6; }
            100% { transform: translateY(110vh) rotate(360deg) translateX(30px); opacity: 0; }
        }

        .bg-texture { z-index: 6; opacity: 0.03; background-image: radial-gradient(circle at 1px 1px, white 1px, transparent 1px); background-size: 50px 50px; }

        .container {
            text-align: center; z-index: 100; padding: 55px 65px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.97) 0%, rgba(255, 252, 253, 0.98) 50%, rgba(255, 248, 250, 0.97) 100%);
            border-radius: 24px;
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.4), 0 20px 60px rgba(100, 30, 50, 0.3), 0 0 0 1px rgba(255, 200, 210, 0.5), inset 0 1px 0 rgba(255, 255, 255, 1), inset 0 -1px 0 rgba(200, 150, 160, 0.1);
            position: relative; max-width: 560px; width: 90%;
            animation: containerFloat 6s ease-in-out infinite, containerIn 1s ease-out;
        }

        @keyframes containerIn { 0% { opacity: 0; transform: translateY(40px) scale(0.95); } 100% { opacity: 1; transform: translateY(0) scale(1); } }
        @keyframes containerFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

        .container::before { content: ''; position: absolute; top: 12px; left: 12px; right: 12px; bottom: 12px; border: 1.5px solid rgba(200, 120, 140, 0.25); border-radius: 16px; pointer-events: none; }
        .container::after { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background: linear-gradient(135deg, rgba(255, 180, 200, 0.4), rgba(255, 150, 180, 0.2), rgba(255, 200, 220, 0.3)); border-radius: 26px; z-index: -1; filter: blur(20px); opacity: 0.7; animation: glowPulse 4s ease-in-out infinite; }

        @keyframes glowPulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 0.8; transform: scale(1.02); } }

        .corner-decor { position: absolute; font-size: 32px; filter: drop-shadow(0 4px 8px rgba(150, 50, 80, 0.3)); animation: cornerPulse 3s ease-in-out infinite; }
        .corner-decor.tl { top: -16px; left: -16px; }
        .corner-decor.tr { top: -16px; right: -16px; animation-delay: 0.75s; }
        .corner-decor.bl { bottom: -16px; left: -16px; animation-delay: 1.5s; }
        .corner-decor.br { bottom: -16px; right: -16px; animation-delay: 2.25s; }

        @keyframes cornerPulse { 0%, 100% { transform: scale(1) rotate(0deg); } 50% { transform: scale(1.15) rotate(5deg); } }

        .title { margin-bottom: 8px; }
        .title h1 { font-family: 'Cormorant Garamond', serif; font-size: 2.4rem; font-weight: 700; color: #8b2942; letter-spacing: 2px; margin-bottom: 6px; }
        .title-hearts { color: #d64060; font-size: 1.4rem; letter-spacing: 8px; }
        .subtitle { font-size: 0.75rem; font-weight: 600; color: #b08090; letter-spacing: 5px; text-transform: uppercase; margin-top: 8px; }
        .separator { width: 80px; height: 2px; background: linear-gradient(90deg, transparent, #d4a0b0, transparent); margin: 25px auto; }
        .question { font-family: 'Cormorant Garamond', serif; font-size: 1.65rem; font-weight: 600; color: #4a3040; line-height: 1.6; margin: 25px 0; }
        .question-heart { display: inline-block; color: #d64060; animation: heartBeat 1.2s ease-in-out infinite; margin-left: 5px; }

        @keyframes heartBeat { 0%, 100% { transform: scale(1); } 15% { transform: scale(1.25); } 30% { transform: scale(1); } 45% { transform: scale(1.2); } 60% { transform: scale(1); } }

        .buttons-container { display: flex; justify-content: center; align-items: center; gap: 25px; margin-top: 35px; position: relative; min-height: 60px; }
        .btn { padding: 15px 40px; font-size: 1.1rem; font-weight: 700; font-family: 'Quicksand', sans-serif; border: none; border-radius: 50px; cursor: pointer; letter-spacing: 1px; transition: transform 0.3s ease, box-shadow 0.3s ease; min-width: 140px; text-align: center; }
        .btn-yes { background: linear-gradient(135deg, #a24857 0%, #8b2942 50%, #6d1f35 100%); color: #fff; box-shadow: 0 8px 30px rgba(139, 41, 66, 0.5), 0 4px 15px rgba(109, 31, 53, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 150, 180, 0.3); }
        .btn-yes:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 15px 40px rgba(139, 41, 66, 0.6), 0 8px 20px rgba(109, 31, 53, 0.5), 0 0 20px rgba(255, 100, 130, 0.3); }
        .btn-no { background: linear-gradient(135deg, #5a4a50 0%, #4a3a42 50%, #3a2a32 100%); color: rgba(255, 255, 255, 0.9); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 200, 210, 0.2); width: 140px; min-width: 140px; max-width: 140px; height: 52px; padding: 0; display: flex; align-items: center; justify-content: center; position: relative; transition: transform 0.3s ease, left 0.3s ease, box-shadow 0.3s ease; }

        .sad-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 9999; animation: sadIn 0.3s ease; }
        @keyframes sadIn { 0% { opacity: 0; } 100% { opacity: 1; } }
        .sad-emoji { font-size: 200px; animation: sadBounce 0.6s ease; }
        @keyframes sadBounce { 0% { transform: scale(0) rotate(-20deg); } 50% { transform: scale(1.2) rotate(10deg); } 100% { transform: scale(1) rotate(0deg); } }

        .success-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 500; display: flex; justify-content: center; align-items: center; animation: fadeIn 0.8s ease; }
        @keyframes fadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }

        .success-bg-base, .success-bg-aurora, .success-bg-bokeh, .success-bg-particles, .success-bg-falling { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .success-bg-base { background: radial-gradient(ellipse at 10% 20%, rgba(120, 50, 80, 0.4) 0%, transparent 50%), radial-gradient(ellipse at 90% 80%, rgba(180, 80, 100, 0.3) 0%, transparent 50%), radial-gradient(ellipse at 50% 50%, rgba(60, 20, 40, 0.2) 0%, transparent 70%), linear-gradient(180deg, #1a0a10 0%, #2d1520 30%, #3d1f2d 60%, #2a1018 100%); z-index: 1; }
        .success-bg-aurora { opacity: 0.4; background: linear-gradient(135deg, transparent 0%, rgba(255, 100, 150, 0.1) 50%, transparent 100%); animation: auroraMove 15s ease-in-out infinite; z-index: 2; }
        .success-bg-bokeh { z-index: 3; }
        .success-bg-particles { z-index: 4; }
        .success-bg-falling { z-index: 5; pointer-events: none; }

        .success-card { text-align: center; padding: 50px 60px; background: linear-gradient(145deg, rgba(255, 255, 255, 0.97) 0%, rgba(255, 252, 253, 0.98) 50%, rgba(255, 248, 250, 0.97) 100%); border-radius: 24px; box-shadow: 0 50px 100px rgba(0, 0, 0, 0.4), 0 20px 60px rgba(100, 30, 50, 0.3), 0 0 0 1px rgba(255, 200, 210, 0.5); z-index: 100; animation: cardPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275); max-width: 500px; width: 90%; position: relative; }
        .success-card::before { content: ''; position: absolute; top: 12px; left: 12px; right: 12px; bottom: 12px; border: 1.5px solid rgba(200, 120, 140, 0.25); border-radius: 16px; pointer-events: none; }
        @keyframes cardPop { 0% { opacity: 0; transform: scale(0.8) translateY(30px); } 100% { opacity: 1; transform: scale(1) translateY(0); } }
        .success-card h2 { font-family: 'Cormorant Garamond', serif; font-size: 2.3rem; font-weight: 700; color: #8b2942; margin-bottom: 10px; }
        .success-card p { font-family: 'Quicksand', sans-serif; font-size: 1.2rem; color: #6a4a55; margin-bottom: 30px; }
        .btn-magic { padding: 18px 45px; font-size: 1.15rem; font-weight: 700; font-family: 'Quicksand', sans-serif; background: linear-gradient(135deg, #a24857 0%, #8b2942 50%, #6d1f35 100%); color: #fff; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 8px 30px rgba(139, 41, 66, 0.5), 0 4px 15px rgba(109, 31, 53, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 150, 180, 0.3); transition: transform 0.3s, box-shadow 0.3s; animation: magicGlow 2s ease-in-out infinite; }
        @keyframes magicGlow { 0%, 100% { box-shadow: 0 8px 30px rgba(139, 41, 66, 0.5), 0 4px 15px rgba(109, 31, 53, 0.4); } 50% { box-shadow: 0 12px 40px rgba(139, 41, 66, 0.7), 0 8px 25px rgba(109, 31, 53, 0.5), 0 0 30px rgba(255, 100, 130, 0.3); } }
        .btn-magic:hover { transform: translateY(-3px) scale(1.05); }

        .cinema-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000; background: #000; }
        
        .cinema-end { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 100; opacity: 0; transition: opacity 2s ease; }
        .cinema-end h1 { font-family: 'Cormorant Garamond', serif; font-size: 3rem; font-weight: 600; color: white; letter-spacing: 4px; line-height: 1.6; text-shadow: 0 0 40px rgba(255, 255, 255, 0.5), 0 0 80px rgba(255, 100, 150, 0.3); }
        .cinema-end .final-heart { font-size: 60px; margin-top: 30px; display: block; animation: finalBeat 1s ease-in-out infinite; }
        @keyframes finalBeat { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

        @media (max-width: 600px) {
            .container { padding: 40px 25px; margin: 15px; }
            .title h1 { font-size: 1.8rem; }
            .question { font-size: 1.3rem; }
            .btn { min-width: 110px; padding: 12px 25px; font-size: 1rem; }
            .btn-no { width: 110px; min-width: 110px; max-width: 110px; height: 46px; }
            .buttons-container { gap: 15px; }
            .corner-decor { font-size: 24px; }
            .success-card { padding: 35px 25px; }
            .success-card h2 { font-size: 1.7rem; }
            .cinema-end h1 { font-size: 1.5rem; letter-spacing: 2px; }
            .cinema-end .final-heart { font-size: 40px; }
        }
    </style>
</head>
<body>
    <div class="bg-layer bg-base"></div>
    <div class="bg-layer bg-aurora"></div>
    <div class="bg-layer bg-bokeh" id="bokehLayer">
        <div class="bokeh-circle"></div>
        <div class="bokeh-circle"></div>
        <div class="bokeh-circle"></div>
        <div class="bokeh-circle"></div>
    </div>
    <div class="bg-layer bg-particles" id="particlesLayer"></div>
    <div class="bg-layer bg-falling" id="fallingLayer"></div>
    <div class="bg-layer bg-texture"></div>

    <div class="container" id="mainContainer">
        <span class="corner-decor tl">üåπ</span>
        <span class="corner-decor tr">üåπ</span>
        <span class="corner-decor bl">üíê</span>
        <span class="corner-decor br">üíê</span>

        <div class="title">
            <h1>Dla Mojej Jedynej</h1>
            <div class="title-hearts">üíï üíï üíï</div>
            <p class="subtitle">Walentynki 2026</p>
        </div>
        
        <div class="separator"></div>
        
        <p class="question">
            Czy zostaniesz mojƒÖ WalentynkƒÖ? <span class="question-heart">‚ù§Ô∏è</span>
        </p>
        
        <div class="buttons-container" id="btnContainer">
            <button class="btn btn-yes" id="yesBtn">TAK üíñ</button>
            <button class="btn btn-no" id="noBtn">NIE üíî</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ===== STRONA 1 - BEZ ZMIAN =====
        function createParticles() {
            const container = document.getElementById('particlesLayer');
            for (let i = 0; i < 80; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = Math.random() * 100 + '%';
                p.style.top = Math.random() * 100 + '%';
                p.style.width = (1 + Math.random() * 2.5) + 'px';
                p.style.height = p.style.width;
                p.style.animationDelay = Math.random() * 4 + 's';
                p.style.animationDuration = (3 + Math.random() * 3) + 's';
                container.appendChild(p);
            }
        }
        createParticles();

        function createFallingElements() {
            const container = document.getElementById('fallingLayer');
            const items = ['üíï', 'üå∏', 'üíó', '‚ú®', 'üåπ', 'üíñ', 'ü¶ã'];
            
            function addFalling() {
                const el = document.createElement('div');
                el.className = 'falling-item';
                el.textContent = items[Math.floor(Math.random() * items.length)];
                el.style.left = Math.random() * 100 + '%';
                el.style.fontSize = (18 + Math.random() * 20) + 'px';
                el.style.animationDuration = (8 + Math.random() * 8) + 's';
                el.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(el);
                setTimeout(() => el.remove(), 18000);
            }
            
            for (let i = 0; i < 12; i++) setTimeout(addFalling, i * 300);
            setInterval(addFalling, 1500);
        }
        createFallingElements();

        const noBtn = document.getElementById('noBtn');
        const yesBtn = document.getElementById('yesBtn');
        const mainContainer = document.getElementById('mainContainer');
        
        let isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let escapeCount = 0;
        
        function getContainerBounds() {
            const rect = mainContainer.getBoundingClientRect();
            return { left: 20, right: rect.width - noBtn.offsetWidth - 20, top: 150, bottom: rect.height - noBtn.offsetHeight - 20 };
        }
        
        function escapeInContainer() {
            escapeCount++;
            const bounds = getContainerBounds();
            const newX = bounds.left + Math.random() * (bounds.right - bounds.left);
            const newY = bounds.top + Math.random() * (bounds.bottom - bounds.top);
            
            noBtn.style.position = 'absolute';
            noBtn.style.left = newX + 'px';
            noBtn.style.top = newY + 'px';
            noBtn.style.transition = 'left 0.35s ease-out, top 0.35s ease-out';
            
            const texts = ['NIE üíî', 'Nie! üôà', 'Haha! üòú', 'Z≈Çap mnie! üèÉ', 'Niemo≈ºliwe! ‚ú®', 'Wybierz TAK! üíï'];
            noBtn.textContent = texts[Math.min(escapeCount - 1, texts.length - 1)];
        }
        
        if (!isMobile) noBtn.addEventListener('mouseenter', escapeInContainer);
        if (isMobile) noBtn.addEventListener('touchstart', (e) => { e.preventDefault(); escapeInContainer(); });
        
        noBtn.addEventListener('click', (e) => {
            if (isMobile) return;
            const overlay = document.createElement('div');
            overlay.className = 'sad-overlay';
            overlay.innerHTML = '<div class="sad-emoji">üò¢</div>';
            document.body.appendChild(overlay);
            setTimeout(() => overlay.remove(), 1800);
        });

        yesBtn.addEventListener('click', showSuccessScreen);
        
        function showSuccessScreen() {
            mainContainer.style.transition = 'opacity 0.5s, transform 0.5s';
            mainContainer.style.opacity = '0';
            mainContainer.style.transform = 'scale(0.9)';
            
            setTimeout(() => {
                mainContainer.style.display = 'none';
                
                const successScreen = document.createElement('div');
                successScreen.className = 'success-screen';
                successScreen.id = 'successScreen';
                successScreen.innerHTML = `
                    <div class="success-bg-base"></div>
                    <div class="success-bg-aurora"></div>
                    <div class="success-bg-bokeh" id="successBokeh"></div>
                    <div class="success-bg-particles" id="successParticles"></div>
                    <div class="success-bg-falling" id="successFalling"></div>
                    <div class="success-card">
                        <h2>DOSKONA≈ÅY WYB√ìR WIKUSIA üíñ</h2>
                        <p>Kocham Ciƒô najbardziej na ≈õwiecie! üíï</p>
                        <button class="btn-magic" id="magicBtn">‚ú® To teraz czary ‚ú®</button>
                    </div>
                `;
                document.body.appendChild(successScreen);
                
                const bokehContainer = document.getElementById('successBokeh');
                for (let i = 0; i < 4; i++) {
                    const circle = document.createElement('div');
                    circle.className = 'bokeh-circle';
                    bokehContainer.appendChild(circle);
                }
                
                const particlesContainer = document.getElementById('successParticles');
                for (let i = 0; i < 60; i++) {
                    const p = document.createElement('div');
                    p.className = 'particle';
                    p.style.left = Math.random() * 100 + '%';
                    p.style.top = Math.random() * 100 + '%';
                    p.style.width = (1 + Math.random() * 2.5) + 'px';
                    p.style.height = p.style.width;
                    p.style.animationDelay = Math.random() * 4 + 's';
                    particlesContainer.appendChild(p);
                }
                
                const fallingContainer = document.getElementById('successFalling');
                const items = ['üíï', 'üå∏', 'üíó', '‚ú®', 'üåπ', 'üíñ', '‚ù§Ô∏è'];
                
                function addSuccessFalling() {
                    const el = document.createElement('div');
                    el.className = 'falling-item';
                    el.textContent = items[Math.floor(Math.random() * items.length)];
                    el.style.left = Math.random() * 100 + '%';
                    el.style.fontSize = (20 + Math.random() * 25) + 'px';
                    el.style.animationDuration = (6 + Math.random() * 6) + 's';
                    fallingContainer.appendChild(el);
                    setTimeout(() => el.remove(), 14000);
                }
                
                for (let i = 0; i < 15; i++) setTimeout(addSuccessFalling, i * 200);
                const fallingInterval = setInterval(addSuccessFalling, 800);
                
                document.getElementById('magicBtn').addEventListener('click', () => {
                    clearInterval(fallingInterval);
                    startCinema();
                });
                
            }, 500);
        }

        // ===== ANIMACJA 3D THREE.JS =====
        function startCinema() {
            document.getElementById('successScreen').remove();
            
            const cinema = document.createElement('div');
            cinema.className = 'cinema-container';
            cinema.innerHTML = `
                <div class="cinema-end" id="cinemaEnd">
                    <h1>DZIƒòKUJƒò ZA KOLEJNY<br>WSPANIA≈ÅY ROK</h1>
                    <span class="final-heart">üíï</span>
                </div>
            `;
            document.body.appendChild(cinema);

            // Three.js Setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            cinema.insertBefore(renderer.domElement, cinema.firstChild);

            // Sky gradient
            const skyGeo = new THREE.SphereGeometry(800, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x000022) },
                    bottomColor: { value: new THREE.Color(0x000044) },
                    progress: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float progress;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition).y * 0.5 + 0.5;
                        vec3 spaceTop = vec3(0.0, 0.0, 0.05);
                        vec3 spaceBottom = vec3(0.0, 0.0, 0.15);
                        vec3 skyTop = vec3(0.4, 0.7, 1.0);
                        vec3 skyBottom = vec3(0.7, 0.85, 1.0);
                        vec3 finalTop = mix(spaceTop, skyTop, progress);
                        vec3 finalBottom = mix(spaceBottom, skyBottom, progress);
                        gl_FragColor = vec4(mix(finalBottom, finalTop, h), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);

            // Stars
            const starsGeo = new THREE.BufferGeometry();
            const starsCount = 2000;
            const starPos = new Float32Array(starsCount * 3);
            for (let i = 0; i < starsCount; i++) {
                const r = 500 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                starPos[i * 3 + 1] = r * Math.cos(phi);
                starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, transparent: true, opacity: 1 });
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);

            // Moon
            const moonGeo = new THREE.SphereGeometry(20, 32, 32);
            const moonMat = new THREE.MeshStandardMaterial({ color: 0xffffee, emissive: 0x333322, roughness: 0.8 });
            const moon = new THREE.Mesh(moonGeo, moonMat);
            moon.position.set(150, 180, -300);
            scene.add(moon);

            // Sun
            const sunGeo = new THREE.SphereGeometry(30, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(200, 100, -200);
            sun.visible = false;
            scene.add(sun);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(600, 600, 100, 100);
            const posAttr = groundGeo.getAttribute('position');
            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i);
                const y = posAttr.getY(i);
                posAttr.setZ(i, Math.sin(x * 0.02) * 3 + Math.cos(y * 0.02) * 3);
            }
            groundGeo.computeVertexNormals();
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -25;
            ground.receiveShadow = true;
            scene.add(ground);

            // Trees
            function createTree(x, z, scale = 1) {
                const tree = new THREE.Group();
                
                const trunkGeo = new THREE.CylinderGeometry(0.8 * scale, 1.2 * scale, 10 * scale, 8);
                const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 5 * scale;
                trunk.castShadow = true;
                tree.add(trunk);
                
                const colors = [0x228B22, 0x2E8B2E, 0x32CD32];
                for (let i = 0; i < 3; i++) {
                    const leafGeo = new THREE.ConeGeometry((7 - i * 1.5) * scale, (10 - i * 2) * scale, 8);
                    const leafMat = new THREE.MeshLambertMaterial({ color: colors[i] });
                    const leaf = new THREE.Mesh(leafGeo, leafMat);
                    leaf.position.y = (12 + i * 5) * scale;
                    leaf.castShadow = true;
                    tree.add(leaf);
                }
                
                tree.position.set(x, -25, z);
                return tree;
            }

            const treePositions = [[-70, -40], [-50, -60], [60, -50], [80, -30], [-80, 30], [90, 40]];
            treePositions.forEach(([x, z]) => scene.add(createTree(x, z, 0.8 + Math.random() * 0.4)));

            // Flowers
            const flowers = [];
            for (let i = 0; i < 40; i++) {
                const flowerGroup = new THREE.Group();
                
                const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
                const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = 1.5;
                flowerGroup.add(stem);
                
                const petalColors = [0xff69b4, 0xff1493, 0xffb6c1, 0xff6b6b, 0xffd700];
                const petalColor = petalColors[Math.floor(Math.random() * petalColors.length)];
                
                for (let j = 0; j < 6; j++) {
                    const petalGeo = new THREE.SphereGeometry(0.4, 8, 8);
                    const petalMat = new THREE.MeshLambertMaterial({ color: petalColor });
                    const petal = new THREE.Mesh(petalGeo, petalMat);
                    const angle = (j / 6) * Math.PI * 2;
                    petal.position.set(Math.cos(angle) * 0.6, 3, Math.sin(angle) * 0.6);
                    petal.scale.set(1, 0.4, 0.6);
                    flowerGroup.add(petal);
                }
                
                const centerGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const centerMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                const center = new THREE.Mesh(centerGeo, centerMat);
                center.position.y = 3;
                flowerGroup.add(center);
                
                flowerGroup.position.set((Math.random() - 0.5) * 150, -25, (Math.random() - 0.5) * 150);
                flowerGroup.userData.phase = Math.random() * Math.PI * 2;
                flowers.push(flowerGroup);
                scene.add(flowerGroup);
            }

            // Clouds
            function createCloud(x, y, z) {
                const cloud = new THREE.Group();
                const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
                
                for (let i = 0; i < 5; i++) {
                    const size = 3 + Math.random() * 4;
                    const partGeo = new THREE.SphereGeometry(size, 16, 16);
                    const part = new THREE.Mesh(partGeo, cloudMat);
                    part.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 5);
                    cloud.add(part);
                }
                
                cloud.position.set(x, y, z);
                cloud.userData.speed = 0.02 + Math.random() * 0.03;
                return cloud;
            }

            const clouds = [];
            for (let i = 0; i < 8; i++) {
                const cloud = createCloud((Math.random() - 0.5) * 400, 50 + Math.random() * 40, -150 - Math.random() * 100);
                clouds.push(cloud);
                scene.add(cloud);
            }

            // Character creator
            function createCharacter(isGirl) {
                const char = new THREE.Group();
                
                // Body
                const bodyGeo = new THREE.CapsuleGeometry(2.5, 5, 8, 16);
                const bodyMat = new THREE.MeshLambertMaterial({ color: isGirl ? 0xff69b4 : 0x4169e1 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 6;
                body.castShadow = true;
                char.add(body);
                
                // Head
                const headGeo = new THREE.SphereGeometry(2.8, 32, 32);
                const headMat = new THREE.MeshLambertMaterial({ color: 0xfdbf91 });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 12;
                head.castShadow = true;
                char.add(head);
                
                // Hair
                if (isGirl) {
                    const hairGeo = new THREE.SphereGeometry(3.2, 32, 32);
                    hairGeo.scale(1, 1.4, 1);
                    const hairMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                    const hair = new THREE.Mesh(hairGeo, hairMat);
                    hair.position.y = 12.5;
                    char.add(hair);
                    
                    for (let side of [-1, 1]) {
                        const sideHairGeo = new THREE.CapsuleGeometry(1, 8, 8, 16);
                        const sideHair = new THREE.Mesh(sideHairGeo, hairMat);
                        sideHair.position.set(side * 2.5, 8, 0);
                        char.add(sideHair);
                    }
                } else {
                    const hairGeo = new THREE.SphereGeometry(3, 32, 32);
                    hairGeo.scale(1, 0.7, 1);
                    const hairMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
                    const hair = new THREE.Mesh(hairGeo, hairMat);
                    hair.position.y = 13.5;
                    char.add(hair);
                }
                
                // Eyes
                for (let side of [-1, 1]) {
                    const eyeGeo = new THREE.SphereGeometry(0.5, 16, 16);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x3e2723 });
                    const eye = new THREE.Mesh(eyeGeo, eyeMat);
                    eye.position.set(side * 1, 12.5, 2.5);
                    char.add(eye);
                }
                
                // Smile
                const smileGeo = new THREE.TorusGeometry(0.6, 0.15, 8, 16, Math.PI);
                const smileMat = new THREE.MeshBasicMaterial({ color: 0xe57373 });
                const smile = new THREE.Mesh(smileGeo, smileMat);
                smile.position.set(0, 10.5, 2.5);
                smile.rotation.x = Math.PI;
                char.add(smile);
                
                // Arms
                char.userData.arms = [];
                for (let side of [-1, 1]) {
                    const armGroup = new THREE.Group();
                    const armGeo = new THREE.CapsuleGeometry(0.6, 5, 8, 16);
                    const armMat = new THREE.MeshLambertMaterial({ color: 0xfdbf91 });
                    const arm = new THREE.Mesh(armGeo, armMat);
                    arm.position.y = -2;
                    armGroup.add(arm);
                    armGroup.position.set(side * 3.2, 8, 0);
                    char.add(armGroup);
                    char.userData.arms.push(armGroup);
                }
                
                // Legs
                char.userData.legs = [];
                for (let side of [-1, 1]) {
                    const legGroup = new THREE.Group();
                    const legGeo = new THREE.CapsuleGeometry(0.8, 6, 8, 16);
                    const legMat = new THREE.MeshLambertMaterial({ color: 0x3f51b5 });
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.y = -3;
                    legGroup.add(leg);
                    
                    const shoeGeo = new THREE.BoxGeometry(1.5, 1, 2.5);
                    const shoeMat = new THREE.MeshLambertMaterial({ color: isGirl ? 0xe91e63 : 0x212121 });
                    const shoe = new THREE.Mesh(shoeGeo, shoeMat);
                    shoe.position.set(0, -6.5, 0.3);
                    legGroup.add(shoe);
                    
                    legGroup.position.set(side * 1.2, 2, 0);
                    char.add(legGroup);
                    char.userData.legs.push(legGroup);
                }
                
                return char;
            }

            // Characters
            const girl = createCharacter(true);
            girl.position.set(-18, 150, 0);
            girl.visible = false;
            scene.add(girl);

            const boy = createCharacter(false);
            boy.position.set(80, -25, 0);
            boy.visible = false;
            scene.add(boy);

            // Cupid
            function createCupid() {
                const cupid = new THREE.Group();
                
                const bodyGeo = new THREE.SphereGeometry(2.5, 32, 32);
                bodyGeo.scale(1, 1.3, 0.8);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0xffecd2 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                cupid.add(body);
                
                const headGeo = new THREE.SphereGeometry(2.2, 32, 32);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.y = 4;
                cupid.add(head);
                
                const hairMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                for (let i = 0; i < 12; i++) {
                    const curlGeo = new THREE.SphereGeometry(0.6, 16, 16);
                    const curl = new THREE.Mesh(curlGeo, hairMat);
                    const angle = (i / 12) * Math.PI * 2;
                    curl.position.set(Math.cos(angle) * 1.8, 4.5 + Math.sin(i) * 0.3, Math.sin(angle) * 1.8);
                    cupid.add(curl);
                }
                
                for (let side of [-0.7, 0.7]) {
                    const eyeGeo = new THREE.SphereGeometry(0.35, 16, 16);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x4a90d9 });
                    const eye = new THREE.Mesh(eyeGeo, eyeMat);
                    eye.position.set(side, 4.3, 1.9);
                    cupid.add(eye);
                }
                
                cupid.userData.wings = [];
                const wingMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
                
                for (let side of [-1, 1]) {
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0);
                    wingShape.bezierCurveTo(side * 3, 3, side * 6, 4, side * 7, 0);
                    wingShape.bezierCurveTo(side * 6, -2, side * 3, -2, 0, 0);
                    
                    const wingGeo = new THREE.ShapeGeometry(wingShape);
                    const wing = new THREE.Mesh(wingGeo, wingMat);
                    wing.position.set(side * 2, 1, -1);
                    cupid.add(wing);
                    cupid.userData.wings.push(wing);
                }
                
                return cupid;
            }

            const cupid = createCupid();
            cupid.position.set(0, 150, 40);
            cupid.visible = false;
            scene.add(cupid);

            // Arrow
            function createArrow() {
                const arrow = new THREE.Group();
                
                const shaftGeo = new THREE.CylinderGeometry(0.15, 0.15, 8, 8);
                shaftGeo.rotateZ(Math.PI / 2);
                const shaftMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const shaft = new THREE.Mesh(shaftGeo, shaftMat);
                arrow.add(shaft);
                
                const heartShape = new THREE.Shape();
                heartShape.moveTo(0, 0);
                heartShape.bezierCurveTo(0.5, 0.5, 1, 0, 1, -0.5);
                heartShape.bezierCurveTo(1, -1, 0, -1.5, 0, -2);
                heartShape.bezierCurveTo(0, -1.5, -1, -1, -1, -0.5);
                heartShape.bezierCurveTo(-1, 0, -0.5, 0.5, 0, 0);
                
                const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth: 0.5, bevelEnabled: false });
                const heartMat = new THREE.MeshLambertMaterial({ color: 0xff1493 });
                const heart = new THREE.Mesh(heartGeo, heartMat);
                heart.rotation.x = -Math.PI / 2;
                heart.rotation.y = Math.PI;
                heart.position.x = 5;
                heart.scale.setScalar(0.8);
                arrow.add(heart);
                
                return arrow;
            }

            const arrows = [];

            // Hug couple
            const hugCouple = new THREE.Group();
            hugCouple.visible = false;
            
            const hugBodyGeo = new THREE.CapsuleGeometry(5, 6, 16, 32);
            const hugBodyMat = new THREE.MeshLambertMaterial({ color: 0xdda0dd });
            const hugBody = new THREE.Mesh(hugBodyGeo, hugBodyMat);
            hugBody.position.y = 5;
            hugCouple.add(hugBody);
            
            const hugHeadMat = new THREE.MeshLambertMaterial({ color: 0xfdbf91 });
            const hugGirlHead = new THREE.Mesh(new THREE.SphereGeometry(2.5, 32, 32), hugHeadMat);
            hugGirlHead.position.set(-2, 12, 0);
            hugCouple.add(hugGirlHead);
            
            const hugBoyHead = new THREE.Mesh(new THREE.SphereGeometry(2.5, 32, 32), hugHeadMat);
            hugBoyHead.position.set(2, 12, 0);
            hugCouple.add(hugBoyHead);
            
            const hugGirlHair = new THREE.Mesh(new THREE.SphereGeometry(2.8, 32, 32), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
            hugGirlHair.position.set(-2, 12.5, -0.5);
            hugGirlHair.scale.set(1, 1.3, 1);
            hugCouple.add(hugGirlHair);
            
            const hugBoyHair = new THREE.Mesh(new THREE.SphereGeometry(2.7, 32, 32), new THREE.MeshLambertMaterial({ color: 0x8b7355 }));
            hugBoyHair.position.set(2, 13.5, -0.3);
            hugBoyHair.scale.set(1, 0.6, 1);
            hugCouple.add(hugBoyHair);
            
            hugCouple.position.set(0, -25, 0);
            scene.add(hugCouple);

            // Floating hearts
            const floatingHearts = [];
            
            function createHeart3D() {
                const shape = new THREE.Shape();
                shape.moveTo(0, 0);
                shape.bezierCurveTo(0.5, 0.5, 1, 0, 1, -0.5);
                shape.bezierCurveTo(1, -1, 0, -1.5, 0, -2);
                shape.bezierCurveTo(0, -1.5, -1, -1, -1, -0.5);
                shape.bezierCurveTo(-1, 0, -0.5, 0.5, 0, 0);
                
                const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: true, bevelSize: 0.1, bevelThickness: 0.1 });
                const mat = new THREE.MeshLambertMaterial({ color: 0xff69b4 });
                return new THREE.Mesh(geo, mat);
            }

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(100, 150, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            const moonLight = new THREE.PointLight(0x8888ff, 0.8, 500);
            moonLight.position.copy(moon.position);
            scene.add(moonLight);

            // Camera start position
            camera.position.set(0, 250, 80);
            camera.lookAt(0, 0, 0);

            // Animation state
            let time = 0;
            let animationPhase = 0;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                time += 0.016;
                
                // Sky transition
                const skyProgress = Math.min(1, Math.max(0, (time - 2) / 8));
                skyMat.uniforms.progress.value = skyProgress;
                
                // Stars fade
                starsMat.opacity = Math.max(0, 1 - skyProgress * 1.5);
                
                // Moon/Sun visibility
                moon.visible = skyProgress < 0.7;
                moonLight.intensity = Math.max(0, 0.8 - skyProgress);
                sun.visible = skyProgress > 0.3;
                sunLight.intensity = skyProgress;
                
                // Camera animation
                if (time < 10) {
                    camera.position.y = 250 - time * 25;
                    camera.position.z = 80 + time * 3;
                    camera.lookAt(0, Math.max(-25, camera.position.y - 80), 0);
                } else if (time < 14) {
                    const t = (time - 10) / 4;
                    camera.position.y = 10 + (1 - t) * 10;
                    camera.position.z = 110 - t * 50;
                    camera.lookAt(0, -5, 0);
                } else {
                    camera.position.set(0, 18, 60);
                    camera.lookAt(0, 0, 0);
                }
                
                // Character animations
                if (time > 14 && animationPhase === 0) {
                    animationPhase = 1;
                    girl.visible = true;
                }
                
                if (animationPhase >= 1 && girl.position.y > -25) {
                    girl.position.y -= 3;
                    girl.rotation.z = Math.sin(time * 8) * 0.4;
                    girl.userData.arms.forEach((arm, i) => arm.rotation.z = Math.sin(time * 10 + i * Math.PI) * 1);
                    
                    if (girl.position.y <= -25) {
                        girl.position.y = -25;
                        girl.rotation.z = 0;
                        animationPhase = 2;
                    }
                }
                
                if (animationPhase === 2 && time > 18) {
                    girl.userData.arms.forEach((arm, i) => {
                        arm.rotation.z = Math.sin(time * 12 + i) * 0.6;
                        arm.rotation.x = Math.sin(time * 12) * 0.4;
                    });
                    if (time > 20) animationPhase = 3;
                }
                
                if (animationPhase === 3 && !boy.visible) {
                    boy.visible = true;
                }
                
                if (animationPhase >= 3 && boy.position.x > 18) {
                    boy.position.x -= 0.8;
                    boy.userData.legs.forEach((leg, i) => leg.rotation.x = Math.sin(time * 10 + i * Math.PI) * 0.6);
                    boy.userData.arms.forEach((arm, i) => arm.rotation.x = Math.sin(time * 10 + i * Math.PI + Math.PI/2) * 0.4);
                    
                    if (boy.position.x <= 18) {
                        animationPhase = 4;
                        boy.userData.legs.forEach(leg => leg.rotation.x = 0);
                        boy.userData.arms.forEach(arm => arm.rotation.x = 0);
                    }
                }
                
                if (animationPhase === 4 && time > 24 && !cupid.visible) {
                    cupid.visible = true;
                    animationPhase = 5;
                }
                
                if (animationPhase >= 5 && cupid.position.y > 40) {
                    cupid.position.y -= 1.5;
                    cupid.userData.wings.forEach((wing, i) => {
                        wing.rotation.y = (i === 0 ? -1 : 1) * (0.3 + Math.sin(time * 15) * 0.3);
                    });
                }
                
                if (animationPhase === 5 && cupid.position.y <= 40 && time > 27 && arrows.length === 0) {
                    const arrow1 = createArrow();
                    arrow1.position.copy(cupid.position);
                    arrow1.userData.target = girl.position.clone().add(new THREE.Vector3(0, 5, 0));
                    arrow1.userData.start = cupid.position.clone();
                    arrow1.userData.progress = 0;
                    arrows.push(arrow1);
                    scene.add(arrow1);
                    animationPhase = 6;
                }
                
                if (animationPhase === 6 && time > 28 && arrows.length === 1) {
                    const arrow2 = createArrow();
                    arrow2.position.copy(cupid.position);
                    arrow2.userData.target = boy.position.clone().add(new THREE.Vector3(0, 5, 0));
                    arrow2.userData.start = cupid.position.clone();
                    arrow2.userData.progress = 0;
                    arrows.push(arrow2);
                    scene.add(arrow2);
                }
                
                // Arrow animation
                arrows.forEach(arrow => {
                    if (arrow.userData.progress < 1) {
                        arrow.userData.progress += 0.025;
                        const p = arrow.userData.progress;
                        
                        arrow.position.lerpVectors(arrow.userData.start, arrow.userData.target, p);
                        arrow.position.y += Math.sin(p * Math.PI) * 15;
                        
                        const dir = arrow.userData.target.clone().sub(arrow.position).normalize();
                        arrow.lookAt(arrow.position.clone().add(dir));
                    }
                });
                
                // Hearts
                if (arrows.length === 2 && arrows[1].userData.progress > 0.9 && time % 0.1 < 0.02) {
                    const heart = createHeart3D();
                    heart.position.set((Math.random() - 0.5) * 50, -20, (Math.random() - 0.5) * 30);
                    heart.userData.speed = 0.3 + Math.random() * 0.4;
                    heart.userData.rotSpeed = (Math.random() - 0.5) * 0.1;
                    heart.scale.setScalar(0.3 + Math.random() * 0.4);
                    floatingHearts.push(heart);
                    scene.add(heart);
                    
                    if (animationPhase < 7) animationPhase = 7;
                }
                
                floatingHearts.forEach((heart, i) => {
                    heart.position.y += heart.userData.speed;
                    heart.rotation.y += heart.userData.rotSpeed;
                    heart.rotation.z = Math.sin(time * 3 + i) * 0.3;
                    
                    if (heart.position.y > 60) {
                        scene.remove(heart);
                        floatingHearts.splice(i, 1);
                    }
                });
                
                // Hug transition
                if (animationPhase === 7 && time > 34) {
                    girl.visible = false;
                    boy.visible = false;
                    cupid.visible = false;
                    arrows.forEach(a => scene.remove(a));
                    hugCouple.visible = true;
                    animationPhase = 8;
                }
                
                if (animationPhase === 8) {
                    hugCouple.rotation.y = Math.sin(time * 0.8) * 0.15;
                    hugCouple.position.y = -25 + Math.sin(time * 2) * 0.5;
                }
                
                // Fade out
                if (time > 40) {
                    renderer.domElement.style.opacity = Math.max(0, 1 - (time - 40) / 3);
                    if (time > 43) {
                        document.getElementById('cinemaEnd').style.opacity = '1';
                    }
                }
                
                // Animate clouds
                clouds.forEach(cloud => {
                    cloud.position.x += cloud.userData.speed;
                    if (cloud.position.x > 250) cloud.position.x = -250;
                });
                
                // Animate flowers
                flowers.forEach(flower => {
                    flower.rotation.z = Math.sin(time * 2 + flower.userData.phase) * 0.1;
                });
                
                // Rotate stars
                stars.rotation.y += 0.0002;
                
                // Cupid wing flap
                if (cupid.visible) {
                    cupid.userData.wings.forEach((wing, i) => {
                        wing.rotation.y = (i === 0 ? -1 : 1) * (0.3 + Math.sin(time * 12) * 0.25);
                    });
                }
                
                renderer.render(scene, camera);
            }
            
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
